class Piece

types
	public Type = <I>| <J> | <L> | <O> | <S> | <T> | <Z>;
	public SpriteMap = map Type to Sprite;
	public Coordinate :: x: int y: int;
	public Direction = <Up> | <Down> | <Right>| <Left>;
	public Sprite = seq of Coordinate;

instance variables
	public static pieceTypes: seq of Type := [<I>, <J>, <L>, <O>, <S>, <T>, <Z>];
	public static defaultSprites: SpriteMap := {
		<I> |-> [mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(0, 1), mk_Coordinate(0, 2)],
		<J> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 1)],
		<L> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 1)],
		<S> |-> [mk_Coordinate(1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 0)],
		<Z> |-> [mk_Coordinate(-1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 0)],
		<T> |-> [mk_Coordinate(0, 0), mk_Coordinate(0, -1), mk_Coordinate(1, 0), mk_Coordinate(-1, 0)],
		<O> |-> [mk_Coordinate(0, 0), mk_Coordinate(1, 1), mk_Coordinate(1, 0), mk_Coordinate(0, 1)]
	};
	protected translation: Coordinate;
	protected originalTiles: Sprite;
	protected sprite: Sprite;
	protected symbol: char;
	
operations
	public Piece: int * int * char * Type ==> Piece
	Piece(x,y,s,t) == (
		symbol := s;
		originalTiles := defaultSprites(t);
		sprite := defaultSprites(t);
		translation := mk_Coordinate(0, 0);
		move(x,y);
	);
	
	public getTiles: () ==> seq of Coordinate
	getTiles () == (
		return sprite;
	);
	
	public move: int * int ==> ()
	move(x,y) == (
		translation.x := translation.x + x;
		translation.y := translation.y + y;
		for inc = 1 to len sprite do (
			sprite(inc).x := sprite(inc).x + x;
			sprite(inc).y := sprite(inc).y + y;
		);
	);
	
	public getSymbol : () ==> char
	getSymbol () == return symbol;
	
	public rotate: nat1 ==> ()
	rotate(rot) == (
		return;
	);
	
functions

end Piece