class Piece

types
	public Type = <I>| <J> | <L> | <O> | <S> | <T> | <Z>;
	public Coordinate :: x: int y: int;
	public Direction = <Up> | <Down> | <Right>| <Left>;
	public Sprite = seq of Coordinate;

instance variables
	public static pieceTypes: seq of Type := [<I>, <J>, <L>, <O>, <S>, <T>, <Z>];
	protected translation: Coordinate;
	protected originalTiles: Sprite;
	protected tiles: Sprite;
	protected symbol: char;
	
operations
	public Piece: int * int * char * Sprite ==> Piece
	Piece(x,y,s,t) == (
		symbol := s;
		originalTiles := t;
		tiles := t;
		translation := mk_Coordinate(0, 0);
		move(x,y);
	);
	
	public static createNewPiece: Type ==> Piece
	createNewPiece(t) == (
		dcl p: Piece;
		cases t: 
			<I> -> p := new IShapePiece(),
			<J> -> p := new JShapePiece(),
			<L> -> p := new LShapePiece(),
			<O> -> p := new OShapePiece(),
			<S> -> p := new SShapePiece(),
			<T> -> p := new TShapePiece(),
			<Z> -> p := new ZShapePiece()
		end;
		return p;
	);
	
	public getTiles: () ==> seq of Coordinate
	getTiles () == (
		return tiles;
	);
	
	public move: int * int ==> ()
	move(x,y) == (
		translation.x := translation.x + x;
		translation.y := translation.y + y;
		for inc = 1 to len tiles do (
			tiles(inc).x := tiles(inc).x + x;
			tiles(inc).y := tiles(inc).y + y;
		);
	);
	
	public getSymbol : () ==> char
	getSymbol () == return symbol;
	
	public rotate: nat1 ==> ()
	rotate(rot) == is subclass responsibility;
	
functions

end Piece