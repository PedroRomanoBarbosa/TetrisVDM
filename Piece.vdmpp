class Piece

types
	public Type = <I>| <J> | <L> | <O> | <S> | <T> | <Z>;
	public SpriteMap = map Type to Sprite;
	public Coordinate :: x: int y: int;
	public Sprite = seq of Coordinate;
	
values
	public DEFAULT_SPRITES: SpriteMap = {
		<I> |-> [mk_Coordinate(-1, -1), mk_Coordinate(0, -1), mk_Coordinate(1, -1), mk_Coordinate(2, -1)],
		<J> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 1)],
		<L> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 1)],
		<S> |-> [mk_Coordinate(1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 0)],
		<Z> |-> [mk_Coordinate(-1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 0)],
		<T> |-> [mk_Coordinate(0, 0), mk_Coordinate(0, -1), mk_Coordinate(1, 0), mk_Coordinate(-1, 0)],
		<O> |-> [mk_Coordinate(0, 0), mk_Coordinate(1, 1), mk_Coordinate(1, 0), mk_Coordinate(0, 1)]
	};

instance variables
	protected translation: Coordinate;
	protected originalTiles: Sprite;
	protected sprite: Sprite;
	protected symbol: char;
	
operations
	public Piece: int * int * Type * char ==> Piece
	Piece(x,y,t,s) == (
		symbol := s;
		originalTiles := DEFAULT_SPRITES(t);
		sprite := DEFAULT_SPRITES(t);
		translation := mk_Coordinate(0, 0);
		move(x,y);
	);
	
	public static createNewPiece: Type * char ==> Piece
	createNewPiece(type, s) == (
		dcl p: Piece;
		cases type:
			<O> -> p := new Piece(0, 0, type, s),
			<I> -> p := new IShapePiece(0, 0, s),
			others -> p := new PivotPiece(0, 0, type, s)
		end;
		return p;
	);
	
	public getSprite: () ==> Sprite
	getSprite () == (
		return sprite;
	);
	
	public getTranslation: () ==> Coordinate
	getTranslation() == (
		return translation;
	);
	
	public setTranslation: int * int ==> ()
	setTranslation(x, y) == (
		translation.x := x;
		translation.y := y;
	);
	
	public move: int * int ==> ()
	move(x,y) == (
		translation.x := translation.x + x;
		translation.y := translation.y + y;
		sprite := translateSprite(sprite, x, y);
	);
	
	protected translateSprite: Sprite * int * int ==> Sprite
	translateSprite(sp, x, y) == (
		dcl newSp: Sprite := sp;
		for inc = 1 to len sp do (
			newSp(inc).x := sp(inc).x + x;
			newSp(inc).y := sp(inc).y + y;
		);
		return newSp;
	);
	
	public getSymbol : () ==> char
	getSymbol () == return symbol;
	
	public rotate: nat1 ==> ()
	rotate(rot) == (
		return;
	);
	
	public getRotation: () ==> nat1
	getRotation() == (
		return 1;
	);
	
	public setRotation: nat1 ==> ()
	setRotation(rot) == (
		return;
	);
	
functions

end Piece