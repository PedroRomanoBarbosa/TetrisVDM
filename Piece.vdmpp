class Piece

types
	public Type = <I>| <J> | <L> | <O> | <S> | <T> | <Z>;
	public SpriteMap = map Type to Sprite;
	public Coordinate :: x: int y: int;
	public Sprite = seq of Coordinate;
	
values
	public defaultSprites: SpriteMap = {
		<I> |-> [mk_Coordinate(-1, -1), mk_Coordinate(0, -1), mk_Coordinate(1, -1), mk_Coordinate(2, -1)],
		<J> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 1)],
		<L> |-> [mk_Coordinate(0, 1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 1)],
		<S> |-> [mk_Coordinate(1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(-1, 0)],
		<Z> |-> [mk_Coordinate(-1, -1), mk_Coordinate(0, -1), mk_Coordinate(0, 0), mk_Coordinate(1, 0)],
		<T> |-> [mk_Coordinate(0, 0), mk_Coordinate(0, -1), mk_Coordinate(1, 0), mk_Coordinate(-1, 0)],
		<O> |-> [mk_Coordinate(0, 0), mk_Coordinate(1, 1), mk_Coordinate(1, 0), mk_Coordinate(0, 1)]
	};

instance variables
	protected translation: Coordinate;
	protected originalTiles: Sprite;
	protected sprite: Sprite;
	protected symbol: char;
	
operations
	public Piece: int * int * Type * char ==> Piece
	Piece(x,y,t,s) == (
		symbol := s;
		originalTiles := defaultSprites(t);
		sprite := defaultSprites(t);
		translation := mk_Coordinate(0, 0);
		move(x,y);
	);
	
	public static createNewPiece: Type * char ==> Piece
	createNewPiece(type, s) == (
		dcl p: Piece;
		cases type:
			<O> -> p := new Piece(0, 0, type, s),
			<I> -> p := new IShapePiece(0, 0, s),
			others -> p := new PivotPiece(0, 0, type, s)
		end;
		return p;
	);
	
	public getTiles: () ==> seq of Coordinate
	getTiles () == (
		return sprite;
	);
	
	public move: int * int ==> ()
	move(x,y) == (
		translation.x := translation.x + x;
		translation.y := translation.y + y;
		for inc = 1 to len sprite do (
			sprite(inc).x := sprite(inc).x + x;
			sprite(inc).y := sprite(inc).y + y;
		);
	);
	
	public getSymbol : () ==> char
	getSymbol () == return symbol;
	
	public rotate: nat1 ==> ()
	rotate(rot) == (
		return;
	);
	
functions

end Piece